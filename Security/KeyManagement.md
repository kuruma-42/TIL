### 키 생성

- 난수를 이용한 키 생성
- 패스워드를 이용한 키 생성

### 난수를 이용한 키 생성

- 난수 사용
    - 이유 → 키 성질로 ‘다른 사람이 추측하기 어려워야 한다’를 가져야 하기 때문
    - 난수는 추측하기 어렵기 때문에 키로 적합
    - 난수
        - RNG → H/W 컴퓨터의 노이즈를 암호로 난수 생성
        - PRNG → S/W , rand()
        - 무작위성
        - 예측 불가능성
        - 재현 불가능성
            - 주기가 없어야 한다는 말
            - 소프트웨어적으로는, 언젠가는 재현이 된다.
- 난수 생성
    - 하드웨어를 사용하는 것이 좋지만
    - 통상적으로 암호용으로 설계된 의사난수 생성기 소프트웨어를 사용

### 의사난수 만들기

- 암호용으로 이용하는 의사난수 생성기로 생성: ‘예측 불가능’ 성질을 갖음

### 패스워드

- 패스워드 혹은 패스 프레이즈로부터 키를 생성
- Passphrase: 복수의 단어로 이루어지는 긴 패스워드
- password를 키로 직접 이용하지 않고, password를 일방향 해시 함수에 입력해서 얻어진 해시 값으 키로 이용

### PBE와 솔트(salt)

- password based encryption; PBE
    - password에 salt라 불리는 난수를 부가해서 
    일방향 해시 함수에 입력하고 그 출력을 키로 사용
    - 사전 공격(dictionary attack0을 막기 위한 조치
        - e.g. Alice가 좋아하는 단어들을 미리 HashTable을 만들어서 대입해서 공격
        - Salt 값을 넣어서 경우의 수를 늘린다.

### 키 배송

- 키 배송 문제
    - 키를 사전에 공유하는 방법
    - 키 배포 센터를 이용하는 방법 <KDC>
    - Diffle-Hellman 키 교환 <주로 사용>
    - 공개 키 암호를 사용하는 방법 <주로 사용>

### 키 갱신

- 키 갱신(key updating)
    - 공통 키를 사용하여 통신을 하고 있는 중에 정기적으로 키를 교환
    - 송신자와 수신자가 동시에 같은 방법으로 키 교환
    - 현재 키의 해시 값을 다음 키로 사용
- 키 갱신의 장점
    - 백워드 시큐리티(backward security): 키 노출 시 과거 통신의 복호화를 방어

### 키 보존

- 키를 반복해서 사용할 경우 키 보존 문제
    - 키를 암호화해서 보존하는 기술을 사용
- KEK(Key Encryption Key)
    - 키를 암호화하는 키
    - 다수의 키를 한 개의 키(KEK)로 암호화하여 보관

### 키 폐기

- 불필요해 진 키는 확실히 삭제

### Diffie-Hellman 키 교환 (매우 중요)

- 1976년에 Whitfield Diffie와 Martin Hellman이 발명한 알고리즘
- 타인에게 알려져도 상관 없는 정보를 두 사람이 교환하는 것 만으로 공통의 비밀 값을 만들어내는 방법
- IPsec에서는 Diffuse-Hellman 키 교환을 개량한 방법(Oakley 키 결정 프로토콜)을 사용
- 반키를 사용하는 알고리즘

<img width="561" alt="스크린샷 2025-05-05 오후 7 08 00" src="https://github.com/user-attachments/assets/b18f43af-b1f2-4046-a227-4e569bb4d6b5" />


### 원시근의 의미

<img width="425" alt="스크린샷 2025-05-05 오후 7 09 05" src="https://github.com/user-attachments/assets/7598604d-7305-452f-aa67-9001244686d7" />

- e.g. 숫자 **3**을 가지고 시계가 7칸짜리라고 가정
- 3¹ = 3
- 3² = 3×3 = 9 → 시계는 7칸이니까 9는 2
- 3³ = 3×3×3 = 27 → 27은 6 (27에서 7을 몇 번 빼면 6 남음)
- 3⁴ = 81 → 시계 7칸으로 보면 81은 4
- 3⁵ = 243 → 243은 5
- 3⁶ = 729 → 729는 1
- 이렇게 하면 3을 여러 번 곱해서 1, 2, 3, 4, 5, 6 같은 모든 숫자가 다 나온다
- 이럴 때 3을 원시근이라고 한다

### Password Based Encryption; PBE

- 패스워드를 기초로 해서 만든 키로 암호화를 수행하는 방법
- RSA사의 PKCS #5 규격으로 규정되어 있는 PBE Java의 java.crypto 패키지 등에 내장
- 암호 소프트웨어 PGP에서 키를 보존

## PBE 암호화 절차

- 중요한 메시지의 기밀성을 유지하고 싶다.
- 메시지를 그대로 디스크에 보존하면 누군가에게 읽혀질 수 있다.
- 키(CEK)를 사용해서 메시지를 암호화
- 키 CEK의 기밀성 유지해야 한다
- 키 CEK를 그대로 디스크에 보존하는 것은 위험하다
- KEK를 사용해서 CEK를 암호화 하자
- KEK의 기밀성을 유지해야 한다. (빙빙 도는 것에 지나지 않는다)
- 키(KEK)는 패스워드로 부터 만든다
- 패스워드로만 만들면 사전 공격 받을 위험 존재
- KEK는 솔트와 패스워드로 부터 만든다
- 솔트는 암호화한 키 CEK와 함께 보존해두고 KEK는 버리고 자신의 머릿속에 보존해 두기로 한다.

<img width="306" alt="스크린샷 2025-05-05 오후 7 36 10" src="https://github.com/user-attachments/assets/2aa5d3c4-9d4d-4f96-bb28-adc0117660eb" />


### 솔트(Salt)의 역할

- 의사난수 생성기로 만들어지는 랜덤한 수(Salt)로 키(KEK)를 만들 때에 패스워드와 함께 일방향 해시 함수에 입력
- 사전 공격을 막기 위해 필요
- e.g. 2^160 Salt를 넣으면 Table 자체를 만들기가 어렵다

### 패스워드 솔팅 기반의 인증

<img width="504" alt="스크린샷 2025-05-05 오후 7 54 53" src="https://github.com/user-attachments/assets/7f5044fb-c5ed-4a76-820d-58c414364be2" />


- 패스워드 사전 공격을 어렵게 함 → 미리 만들어진 사전에 있는 모든 패스워드 후보 단어들을 사용하는 공격
- 솔트의 길이가 충분히 길 때 무지개표의 크기가 훨씬 늘어나 사전 공격이 어려워짐(해시 계산 비용 증가)
