# SOLID Principle

### 객체지향 프로그래밍의 5가지 설 원칙, SOLID 
- SOLID란 객체 지향 프로그래밍을 하면서 지켜야하는 5대 원칙으로 각각<br>
SRP(단일 책임 원칙)<br>
OCP(개방-폐쇄 원책)<br>
LSP(리스코프 치환 원칙)<br>
DIP(의존 역전 원칙)<br>
ISP(인터페이스 분리 원칙)<br>
상기의 원칙의 앞 글자를 따서 만들어졌다. SOLID 원칙을 철저히 지키면 시간이 지나도 변경이 용이하고,
유지보수와 확장이 쉬운 소프트웨어를 개발하는데 도움이 되는 것으로 알려져있다.

### SRP(Single Responsibility Principle) 단일 책임의 원칙 
- 작성된 클래스는 하나의 기능만 가지며 클래스가 제공하는 모든 서비는 그 하나의 책임을 수행하는 데 집중되어 있어야 한다는 원칙
- 이는 어떤 변화에 의해 클래스를 변경해야 하는 이유는 오직 하나 뿐이어야 함을 의미
- SRP를 적용하면 무엇보다도 책임 영역이 확실해지기 때문에 한 책임의 변경에서 다른 책임의 변경으로의 연쇄작용에서 자유로울 수 있다.
- 뿐만 아니라 책임을 적절히 분배함으로써 코드의 가독성 향상, 유지보수 용이라는 이점까지 누릴 수 있으며 객체지향 원리의 대전제 격인
OCP 원리뿐 아니라 다른 원리들을 적용하는 기초가 됩니다. 이 원리는 다른 원리들에 비해서 개념이 비교적 단순하나, 이 원리를 적용해서 직접 클래스를 설계가히가 
쉽지않다.
- 그 이유는 실무의 프로세스는 매우 복잡하고 다양하고 변경 또한 빈번하기 때문에 경험이 많지 않거나 도메인에 대한 업무 이해가 부족하면 나도 모르게 SRP 원리에서 멀어진다.
* 무조건 책임을 분리한다고 SRP가 적용되는 것은 아니다.


### OCP (Open Close Principal) 개방폐쇄의 원칙 
- 소프트웨어 구성요소(컴포넌트, 클래스, 모듈, 함수)는 확장에는 열려있고, 변경에는 닫혀있어야 한다는 원리
- 이것은 변경을 위한 비용은 가능한 줄이고 확장을 위한 비용은 가능한 극대화 해야 한다는 의미로, 요구사항의 변경이나 추가 사항이 발생하더라도,
기존의 구성요소는 수정이 일어나지 말아야 하며, 기존 구성요소를 쉽게 확장해서 재사용할 수 있어야 한다는 뜻이다.
- OCP는 관리 가능하고 재사용 가능한 코드를 만드는 기반이며, OCP를 가능케 하는 중요 메커니즘은 추상화와 다형성이다.
- OCP는 객체지향의 장점을 극대화 하는 아주 중요한 원리이다.

### LSP (The Liskov Substitution Principle) 
- 서브 타입은 언나 기반 타입으로 교체할 수 있어야 한다. 즉, 서브 타입은 언제든 기반 타입과 호환될 수 있어야 한다
- 서브 타입은 기반 타입이 약속한 규약(public, 물론 메소드가 던지는 예외까지 포함) 을 지켜야 한다.
- 상속은 구현(extends 관계)이든 인터페이스 상속(implements 관계)이든 궁극적으로는 다형성을 통한 확장성 획득을 목표로 한다.
- LSP 원리도 역시 서브 클래스가 확장에 대한 인페이스를 준수해야 함을 의미한다.  
- 일반적으로 선언은 기반 클래스로 생성은구체 클래스로 대입하는 방법을 사용하는 것이 더 좋다.
- 생성 시점에서 구체 클래스를 노출시키기 꺼려질 경우 생성 부분을 Abstract Factory 등의 패턴을 사용하여 유연성을 높일 수 있다.
- 상속을 통한 재사용 기반 클래스와 서브 클래스 사이에 ISA관계가 있을 경우로만 제한해야한다.
- 그 외의 경우는 합성을 이용한 재사용을 해야한다. 상속은 다형성과 따로 생각할 수 없다. 그리고 다형성으로 인한 확장 효과를 얻기 위해서는 서브 클래스가
기반 클래스의 규약을 어겨스닌 안 된다.
- 결국 이 구조는 다형성을 통한 확장의 원리인 OCP를 제공하게 된다.
- 따라서 LSP는 OCP를 구성하는 구조가 된다.
- 객체지지향 설계 원리는 이렇게 서로가 서로를 이용하기도 하고 포함하기도 하는 특징이 존재.







